![image](https://github.com/JavaGrowthStudy/java-study/assets/88030238/5f4955fb-a6e1-4fbc-a2d7-e5a850a7a4e3)# 상속

## 상속이란?
- 기존 클래스의 속성을 물려 받아, 새로운 클래스를 생성하는 것
- **`extends`** : java에서 상속을 위해 사용하는 키워드
  - 하나의 대상만 선택 가능. (**단일상속**만 지원)
    - java는 다중상속을 지원하지 않음!
    - 해결 방안 : `implements` 키워드를 이용한 인터페이스의 **`다중구현`** 으로 해결
> **단일 상속 vs. 다중 상속** <br>
> - 단일 상속
> <img src="https://github.com/JavaGrowthStudy/java-study/assets/88030238/161677ae-2006-43f2-af94-feecb0457fd0" width="50%">

> - 다중 상속 <br>
> <img src="https://github.com/JavaGrowthStudy/java-study/assets/88030238/db44518e-878a-4660-b5e8-32fe09a02bc7" width="50%"> <br>

> **자바가 다중상속을 지원하지 않는 이유** <br>
> <img src="https://github.com/JavaGrowthStudy/java-study/assets/88030238/050f7bbe-c0f7-40e7-9a1b-6e2604a677c9" width="40%"> <br>
> - **`다이아몬드 문제`** 발생 가능성 때문
> 1) `GrandFather` 클래스에 `memberMethod()` 라는 이름의 메소드가 있다고 가정하자.
> 2) `FatherA`와 `FatherB`가 각각  `memberMethod()` 오버라이딩하여 구현했다.
> 3) `FatherA`와 `FatherB`를 모두 상속받은 Son 클래스는 어떤 부모의 `memberMethod()`를 사용해야할지 애매함 -> **충돌** 발생!

## 상속과 메모리 구조
<img src="https://github.com/JavaGrowthStudy/java-study/assets/88030238/161677ae-2006-43f2-af94-feecb0457fd0" width="35%">

#### 1. ` ElectricCar electricCar = new ElectricCar(); `
<img src="https://github.com/JavaGrowthStudy/java-study/assets/88030238/fe8bc3ac-6fea-4c84-8e0e-220203a75d9f" width="75%"><br>
- `new ElectricCar()` 을 호출하면 -> `ElectricCar` 뿐만 아니라 상속 관계에 있는 `Car`이 함께 포함되어 인스턴스가 생성됨
- 참조값은 `x001` 하나이지만, 실제로 그 안에는 `Car`과 `ElectricCar` 두개의 클래스 정보가 공존!
=> 상속은 단순히 부모의 필드와 메서드만 물려 받는 것이 아님. 부모 클래스 자체를 함께 포함하여 객체를 생성!

```
💡 상속 관계의 객체를 생성하면, 인스턴스 내부에 부모와 자식이 모두 생성된다.
```

#### 2. ` electricCar.charge() `
<img src="https://github.com/JavaGrowthStudy/java-study/assets/88030238/5076afb7-82ed-4505-b0f9-c863083252f3" width="80%"><br>
- `electricCar.charge()` 를 호출하면 -> 참조값을 확인하여 `x001.charge()`를 호출함.
- 이때, 상속 관계의 경우 `x001` 내부에 부모와 자식이 모두 존재함.
- 부모인 `Car`을 통해서 `charge()`를 찾을지, `ElectricCar`을 통해서 `charge()`를 찾을지 선택해야 함.
  - 호출하는 변수의 타입(클래스)를 기준으로 선택한다.
  - `electricCar`변수의 타입이 `ElectricCar` 클래스이므로, `ElectricCar`을 통해서 `charge()`를 호출한다.

```
💡 상속 관계의 객체를 호출할 때, 호출자의 타입과 동일한 대상 타입을 찾는다.
```

#### 3. ` electricCar.move() `
<img src="https://github.com/JavaGrowthStudy/java-study/assets/88030238/074a61a7-1ff7-4054-a561-b8d1c3fdceb7" width="80%"><br>
- `elctricCar.move()` 를 호출하면 -> `x001` 참조로 이동
- `Car`, `ElectricCar` 두가지 타입이 있는데, 호출하는 변수인 `electricCar`의 타입인 `ElectricCar` 선택
- 그런데, `ElectricCar`에는 `move()` 메소드가 존재하지 않음!
- 상속 관계에서, 자식 타입에 해당 기능이 없으면 부모 타입으로 올라가서 찾는다.
  - `ElectricCar`의 부모인 `Car`로 올라가서 `move()`를 찾는다.
  - 부모인 `Car`에 `move()`가 존재하므로 부모에 있는 `move()` 메서드를 호출한다.

```
💡 현재 타입에서 기능을 찾지 못하면, 부모 타입으로 이동하여 찾아서 실행한다.
   찾지 못하면 최상위 부모까지 이동하게되고, 그곳에도 없다면 컴파일 오류가 발생한다.
```

## 상속과 기능 추가
<img src="https://github.com/JavaGrowthStudy/java-study/assets/88030238/161677ae-2006-43f2-af94-feecb0457fd0" width="35%">
상속 관계에 메소드와 클래스를 추가해야 한다.
- 모든 차량에 문열기(`openDoor()`) 기능을 추가했다.
- 수소차(`HydrogenCar`) 추가되었다.
    - 수소차는 `fillHydrogen()` 기능을 통해 수소를 충전할 수 있다.

<img src="https://github.com/JavaGrowthStudy/java-study/assets/88030238/73c0bda6-9f21-422e-9e8d-f3c90297a964" width="50%">

#### 1. `Car` 클래스에 `openDoor()` 메서드를 추가한다.
```java
public class Car {
	public void move() {
		System.out.println("차를 이동합니다.");
	}

	//추가
	public void openDoor() {
		System.out.println("문을 엽니다.");
	}
}
```
- 모든 차량에 문열기 기능을 추가하고자 할 때, 상위 부모인 `Car`에 `openDoor()` 기능을 추가하면 된다.
  - 모든 차량이 Car 클래스를 상속하고 있기 때문에 가능하다.

#### 2. `HydrogenCar` 클래스를 추가하고, `fillHydrogen()` 메서드를 추가한다.
```java
public class HydrogenCar extends Car {
	public void fillHydrogen() {
		System.out.println("수소를 충전합니다.");
	}
}
```
- `Car` 클래스를 상속받았기 때문에 `move()`, `openDoor()` 기능을 바로 사용할 수 있다.

#### 3. `ElectricCar` 클래스는 손대지 않아도 된다.
```java
public class ElectricCar extends Car {
	public void charge() {
		System.out.println("충전합니다.");
	}
}
```

#### Main 클래스
```java
public class CarMain {
	public static void main(String[] args) {
	
		ElectricCar electricCar = new ElectricCar();
		electricCar.move(); //차를 이동합니다.
		electricCar.charge(); //충전합니다.
		electricCar.openDoor(); //문을 엽니다.
		
		GasCar gasCar = new GasCar();
		gasCar.move(); //차를 이동합니다.
		gasCar.fillUp(); //기름을 주유합니다.
		gasCar.openDoor(); //문을 엽니다.
		
		HydrogenCar hydrogenCar = new HydrogenCar();
		hydrogenCar.move(); //차를 이동합니다.
		hydrogenCar.fillHydrogen(); //수소를 충전합니다.
		hydrogenCar.openDoor(); //문을 엽니다.
	}
}
```

```
💡 상속관계 덕분에 중복이 줄어들고, 새로운 클래스를 편리하게 확장할 수 있다.
```

## 메서드 오버라이딩과 메모리 구조

## 상속과 접근 제한자

## super - 부모 참조

## super - 생성자
